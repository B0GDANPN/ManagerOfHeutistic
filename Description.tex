\documentclass[12pt]{article}
\input{Preambles/preamble.tex}
\begin{document}
\begin{flushleft}
\section*{Описание менеджера эвристик}

Введём некоторые пояснения.
\newline
Будем измерять сложность компоненты по одной из двух метрик. На её основе введём функцию бюджета в компоненте. Если его достаточно, 
то можно позволить более долгое время оптимизации и более оптимальные эвристики/алгоритмы.
Метрики:
\begin{enumerate}
    \item Количество связных подграфов (\#csg). Это соответствует числу записей в ДП таблице.
    \item Количество пар комплементарных связных подграфов (\#ccp). Пусть $S_1$ и $S_2$ непересекающиеся подмножества отношений в графе, также $S_1$ и $S_2$ - связанные 
    подграфы. И существует ребро между $S_1$ и $S_2$. Тогда  ($S_1$, $S_2$) это пара комплементарных связных подграфов (csg-cmp-pair  ccp).
\end{enumerate}
Каждая эвристика/алгоритм в зависимости от топологии и её сложности, подаваемых на вход, будет иметь стоимость. Эта стоимость будет позже вычитаться из бюджета связной компоненты после планирования. 
\newline
Пусть \textbf{border\_chain}, \textbf{border\_cycle}, \textbf{border\_star}, \textbf{border\_density\_graph}, \textbf{border\_tree}, \textbf{border\_mixed} - это количество связных подграфов, больше которого топология считается сложной, меньше - лёгкой.
\newline
Звезда это центральная вершина и связанные с ней цепи, каждые две цепи не связаны друг другом.
Вершина будет центральной, если выполнено одно из двух:
\begin{enumerate}
    \item Вершина имеет не меньше 2 соседей и количество её строк более чем в \textbf{border\_star\_dominance} раз больше чем у каждого из соседей.
    \item Соседей не меньше 3.
\end{enumerate}

Назовём граф плотным, если количество рёбер в нём не меньше количества рёбер в плотном графе (от такого же числа вершин), умноженного на \textbf{border\_density}.
\newline

\begin{center}
Первый подход:
\end{center}

Пусть дан большой аналитический запрос. Для его планирования будем выполнять следующие шаги:
\begin{enumerate}
    \item Представим запрос в виде набора связных компонент, любые две таблицы из разных компонент не имеют условий соединения между собой. 
    \item Выделим каждой компоненте бюджет.
    \item Для каждой связной компоненты будем выполнять итеративное разбиение на топологии и их планирование в цикле, пока не получим один план для компоненты. 
    Если что-то получилось выделить, возвращаемся в начало цикла, если нет, то переходим на планирование выделенных топологий и снова в начало цикла:
    \begin{enumerate}
        \item Выделим из компоненты \textbf{плотные графы} (с 4+ вершинами).
        \item Выделим циклы.
        \item Если после выделения  плотных графов и циклов, компонента остаётся связной, то выделим дерево, иначе выделяем звёзды и цепи.
        \item Выделим звёзды с лучами длины до \textbf{ray\_length}.
        \item Выделим цепи оставшиеся цепи.
    \end{enumerate}
    Распределим бюджет компоненты по топологиям в соответствии с их сложностями. Каждая топология после планирования становится вершиной, получаем новую связную компоненту меньшего размера.
    \newline
    Планирование:
    \begin{enumerate}
        \item Если бюджета для текущей топологии не осталось, то планируем эвристически, иначе по сложности: для лёгкой топологии используем встроенный ДП, для 
    тяжёлой эвристику. Эвристики для топологий:
        \begin{enumerate}
            \item Цепь:
            \begin{enumerate}
                \item Дешёвая эвристика: итеративно будем выполнять шаг алгоритма GOO пока стоимость соединения не помещается в бюджет или сложность не станет 
                лёгкой, затем передадим встроенному ДП, с сохранением результатов.
                \item Дорогая эвристика: используем ДП алгоритм для цепочки (описан ниже).
            \end{enumerate}
            \item Цикл: найдем соединение, результат которого имеет наибольшую кардинальность, и разобьём цикл по этом соединению - уберём одну таблицу в этом соединении. Спланируем цепь, и присоединим удалённую таблицу.
            \item Звезда:
            \begin{enumerate}
                \item Сначала спланируем лучи как цепи, затем будем последовательно присоединять к центру полученные отношения, жадно по кардинальности.
                \item Последовательно, жадно по кардинальности, присоединяем к центру начала соседних цепочек.
            \end{enumerate}
            \item Плотный граф: 
            \begin{enumerate}
                \item Лёгкая эвристика: используем GOO.
                \item Дорогая эвристика: IDP-2. Используем GOO, не делая соединения, получаем порядок в виде bushy дерева, затем выбираем самое дешёвое дерево размера до \textbf{k}, 
                планируем его и повторяем, пока не останется одно отношение.
            \end{enumerate}
            \item Дерево:
            \begin{itemize}[label={}]
                \item Дешёвая эвристика GOO.
                \item Дорогая эвристика IKKBZ(\cite{IK}\cite{KBZ})/linDP++.
        \end{itemize}
        \end{enumerate}
    \end{enumerate}
    После планирования топологий на текущей итерации вычтем из бюджета компоненты потраченную сумму.
    \newline
    Делаем проверку на выполнение условий для эвристик на OUTER JOINS и гипер-рёбра (описаны ниже). Если условие выполнено, добавим
соответствующее ребро между сторонами.
    \newline
    Тогда возможны два случая:
    \begin{itemize}[label={}]
        \item Ребро было добавлено внутри одной связной компоненты - ничего не меняется.
        \item Ребро было добавлено между двумя разными связанными компонентами - будет новая связная компонента, у которой бюджет это сумма бюджетов двух родительских компонент.
        Заменим две компоненты на новую.
    \end{itemize}
    \item Объединим планы компоненты запроса алгоритмом GOO(по стоимости) с помощью декартового произведения.
\end{enumerate}


\begin{center}
Второй подход на планирование деревьев:
\end{center}

\begin{enumerate}
    \item Представим запрос в виде набора связных компонент, любые две таблицы из разных компонент не имеют условий соединения между собой. 
    \item Выделим каждой компоненте бюджет.
    \item Для каждой связной компоненты выполним два шага и получим план для компоненты.
    \item Первый шаг
    \begin{itemize}[label={}]
        \item Выделим минимальное по стоимости или кардинальности остовное дерево.
        \item Останутся одиночные отношения, добавление которых в дерево добавило бы рёбра приводящие к циклам.
    \end{itemize}
    Бюджет компоненты используется для планирования дерева. После получим новую связную компоненту меньшего размера в виде топологии дерева или звезды.
    В зависимости от оставшегося бюджета и сложности новой топологии выполним планирование нового дерева или звезды.
    \newline
    
    После каждого шага вычтем из бюджета компоненты потраченную сумму.
    Выполняем проверку и обработку эвристик на гипер-графы и OUTER JOINS после каждого шага как в первом подходе.
    \item Объединим планы компоненты запроса алгоритмом GOO(по стоимости) с помощью декартового произведения.
\end{enumerate}

Гипер-рёбра INNER JOINS:
\begin{itemize}[label={}]
    \item Если условие соединяет более двух таблиц, представляем его как гипер-ребро. Пусть условие охватывает таблицы $R_1,\dots,R_n$. Тогда добавим данное ребро в граф тогда, когда каждое $R_i$ принадлежит одному из отношений A или B, 
    A и B отличны.
\end{itemize}

LEFT OUTER JOINS: 
\begin{itemize}[label={}]
    \item При генерации плана сначала выполняем соединения всех таблиц левой стороны между собой (и с другими таблицами, не связанными с правой стороной, но связанными с левой). После присоединяем правую часть.
\end{itemize}

RIGHT OUTER JOINS:
\begin{itemize}[label={}]
    \item Аналогично LEFT OUTER JOINS, только наоборот.
\end{itemize}

FULL OUTER JOINS:
\begin{itemize}[label={}]
    \item Соединим левую сторону с теми отношениями, у которых есть связь с левой стороной и отсутствует с правой. Аналогичное сделаем и для правой стороны.
    Получится для независимых, по включению таблиц, отношения.
\end{itemize}

\begin{center}
Третий подход на основе статей про DPHyp\cite{DPhyp} и linDP++\cite{LinDP} и адаптивный фреймворк\cite{Adaptive}.
\end{center}
\begin{enumerate}
    \item Представим запрос в виде набора связных компонент, любые две таблицы из разных компонент не имеют условий соединения между собой. 
    \item Выделим каждой компоненте бюджет.
    \item Для каждой связной компоненты выполним и получи план компоненты:
    \begin{itemize}[label={}]
        \item Если компонента лёгкая (\textbf{border\_mixed}) и бюджета достаточно, то планируем компоненту целиком с помощью DPHyp.
        \item Иначе в зависимости от сложности и бюджета используем одну из эвристик:
        \begin{itemize}[label={}]
            \item Тяжёлая эвристика: IKKBZ(\cite{IK}\cite{KBZ})/linDP++.
            \item Лёгкая эвристика: IDP-2 c DPHyp в качестве ДП планировщика.
        \end{itemize}
    \end{itemize}
    Бюджет компоненты используется для планирования дерева. После получим новую связную компоненту меньшего размера в виде топологии дерева или звезды.
    В зависимости от оставшегося бюджета и сложности новой топологии выполним планирование нового дерева или звезды.
    \newline
    
    После каждого шага вычтем из бюджета компоненты потраченную сумму.
    \item Объединим планы компоненты запроса алгоритмом GOO(по стоимости) с помощью декартового произведения.
\end{enumerate}


Описание некоторых алгоритмов эвристик:
\begin{enumerate}
    \item GOO \cite{MoerGOO}: эвристика для создания bushy деревьев. Соединяет пары, те пары отношений, которые имеют наименьшую стоимость (кардинальность) объединения. 
    Повторяем, пока не останется одно отношение.
    \item IDP-2 \cite{IDP}: сначала применяется жадная эвристика для построения деревьев соединений размером до \textbf{k}. 
    Полученное поддерево динамически планируется. Полученное отношение заменяет поддерево в дереве. Повторяем итерации пока не получим одно отношение.
    \item ДП алгоритм для цепочки: 
    \begin{itemize}[label={}]
        \item Создаём DP-таблица dp[i][j], где i и j — индексы начала и конца подцепочки (1 $\le$ i $\le$ j $\le$ n).
        \item dp[i][j] хранит: план для отношения с i по j и точку разбиения k (делит [i, j] и минимизирует стоимость).
        \item Для всех i : dp[i][i] =($R_i$, -1)
        \item Для $i \ne j$: dp[i][j] = $\inf$
        \item В тройном цикле перебираем k: для l = 2 \dots n, для i = 1 \dots n - l + 1, j = i + l - 1, для k = i \dots j - 1
        \item Выбираем такой k, где стоимость соединения подцепочек [i, k] и [k+1, j] минимальна. dp[i][j] =([i, k] $\bowtie$ [k + 1, j], k)
        \item Результат в dp[1,n].
    \end{itemize}
\end{enumerate}

\centering \bibliographystyle{alpha}
\bibliography{Preambles/sources.bib}
\raggedright

\end{flushleft}
\end{document}

